<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Sorting Algorithm Visualizer</title>

    <!-- Compiled and minified CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/0.97.8/css/materialize.min.css">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link rel="stylesheet" href="styles.css">
    <style>
        * {
            padding: 0px;
            margin: 0px;
        }

        div {
            margin: 0px;
        }
    </style>
</head>

<body>
    <nav class="amber">
        <div class="nav-wrapper">
            <a href="#" class="brand-logo center">Sorting Algorithm Visualizer</a>
        </div>
    </nav>

    <main>
        <div id="displayArea" style="background:#404040;"></div>
        <div class="container center-align">
            <div class="row">
                <div class="col s12">
                    <div class="row">
                        <div class="col s4">
                            <label for="currentState">Current State</label>
                            <p class="range-field" id="currentStateRange">
                                <input type="range" id="currentState" value="0" min="0" max="100" />
                            </p>
                        </div>
                        <div class="col s4">
                            <label for="delay">Animation Delay (ms)</label>
                            <p class="range-field" id="delayRange">
                                <input type="range" id="delay" value="50" min="1" max="1000" />
                            </p>
                        </div>
                        <div class="col s4">
                            <label for="numElements">Number of Elements</label>
                            <p class="range-field" id="numElementsRange">
                                <input type="range" id="numElements" value="25" min="2" max="1000" />
                            </p>
                        </div>
                    </div>
                </div>
            </div>
            <div class="row">
                <div class="col s12">
                    <button id="bubble" class="alg waves-effect waves-light btn blue-grey">Bubble</button>
                    <button id="selection" class="alg waves-effect waves-light btn blue-grey">Selection</button>
                    <button id="cocktail" class="alg waves-effect waves-light btn blue-grey">Cocktail Shaker</button>
                    <button id="comb" class="alg waves-effect waves-light btn blue-grey">Comb</button>
                    <button id="insertion" class="alg waves-effect waves-light btn blue-grey">Insertion</button>
                </div>
            </div>
            <div class="row">
                <div class="col s12">
                    <button id="quick" class="alg waves-effect waves-light btn blue-grey">Quick</button>
                    <button id="radixLSD" class="alg waves-effect waves-light btn blue-grey">Radix (LSD)</button>
                    <button id="radixMSD" class="alg waves-effect waves-light btn blue-grey">Radix (MSD)</button>
                    <button id="heap" class="alg waves-effect waves-light btn blue-grey">Heap</button>
                    <button id="merge" class="alg waves-effect waves-light btn blue-grey">Merge</button>
                </div>
            </div>
            <div class="row">
                <div class="col s12">
                    <button id="stepBack" class="waves-effect waves-light btn blue-grey"><i class="material-icons">skip_previous</i></button>
                    <button id="playBack" class="waves-effect waves-light btn blue-grey"><i class="material-icons">fast_rewind</i></button>
                    <button id="stop" class="waves-effect waves-light btn red"><i class="material-icons">stop</i></button>
                    <button id="start" class="waves-effect waves-light btn green"><i class="material-icons">play_arrow</i></button>
                    <button id="stepNext" class="waves-effect waves-light btn blue-grey"><i class="material-icons">skip_next</i></button>
                    <button id="reset" class="waves-effect waves-light btn blue-grey"><i class="material-icons">replay</i></button>
                </div>
            </div>
            <div class="row">
                <ul class="collapsible popout" data-collapsible="accordion">
                    <li>
                        <div class="collapsible-header" style="background-color: #fae400">Bubble Sort</div>
                        <div class="collapsible-body">
                            <div class="complexity">
                                <p class="worst" style="background-color: #faebb4">Worst: O(n)</p>
                                <p class="average" style="background-color: #fee446">Average: O(n<sup>2</sup>)</p>
                                <p class="best" style="background-color: #fdc02f">Best: O(n<sup>2</sup>)</p>
                            </div>
                            <div class="explanation">
                                <p align=left style="background-color: #fef8b8">Bubble sort, sometimes referred to as sinking sort, is a simple sorting algorithm that repeatedly steps through the list to be sorted, compares each pair of adjacent items and swaps them if they are in the wrong order. The pass through the list is repeated until no swaps are needed, which indicates that the list is sorted. The algorithm, which is a comparison sort, is named for the way smaller or larger elements "bubble" to the top of the list. Although the algorithm is simple, it is too slow and impractical for most problems even when compared to insertion sort. It can be practical if the input is usually in sorted order but may occasionally have some out-of-order elements nearly in position.</p>
                            </div>
                        </div>
                    </li>
                    <li>
                        <div class="collapsible-header" style="background-color: #f2dd00">Selection Sort</div>
                        <div class="collapsible-body">
                            <div class="complexity">
                                <p class="worst" style="background-color: #faebb4">Worst: O(n<sup>2</sup>)</p>
                                <p class="average" style="background-color: #fee446">Average: O(n<sup>2</sup>)</p>
                                <p class="best" style="background-color: #fdc02f">Best: O(n<sup>2</sup>)</p>
                            </div>
                            <div class="explanation">
                                <p align=left style="background-color: #fef8b8">In computer science, selection sort is a sorting algorithm, specifically an in-place comparison sort. It has O(n<sup>2</sup>) time complexity, making it inefficient on large lists, and generally performs worse than the similar insertion sort. The algorithm divides the input list into two parts: the sublist of items already sorted, which is built up from left to right at the front (left) of the list, and the sublist of items remaining to be sorted that occupy the rest of the list. Initially, the sorted sublist is empty and the unsorted sublist is the entire input list. The algorithm proceeds by finding the smallest (or largest, depending on sorting order) element in the unsorted sublist, exchanging (swapping) it with the leftmost unsorted element (putting it in sorted order), and moving the sublist boundaries one element to the right.</p>
                            </div>
                        </div>
                    </li>
                    <li>
                        <div class="collapsible-header" style="background-color: #e9d500">Cocktail Shaker Sort</div>
                        <div class="collapsible-body">
                            <div class="complexity">
                                <p class="worst" style="background-color: #faebb4">Worst: O(n<sup>2</sup>)</p>
                                <p class="average" style="background-color: #fee446">Average: O(n<sup>2</sup>)</p>
                                <p class="best" style="background-color: #fdc02f">Best: O(n<sup>2</sup>)</p>
                            </div>
                            <div class="explanation">
                                <p align=left style="background-color: #fef8b8">Cocktail shaker sort, also known as bidirectional bubble sort, cocktail sort, martini sort, shaker sort (which can also refer to a variant of selection sort), ripple sort, shuffle sort, or shuttle sort, is a variation of bubble sort that is both a stable sorting algorithm and a comparison sort. The algorithm differs from a bubble sort in that it sorts in both directions on each pass through the list. This sorting algorithm is only marginally more difficult to implement than a bubble sort, and solves the problem of turtles in bubble sorts. It provides only marginal performance improvements, and does not improve asymptotic performance; like the bubble sort, it is not of practical interest (insertion sort is preferred for simple sorts), though it finds some use in education.</p>
                            </div>
                        </div>
                    </li>
                    <li>
                        <div class="collapsible-header" style="background-color: #dbc800">Comb Sort</div>
                        <div class="collapsible-body">
                            <div class="complexity">
                                <p class="worst" style="background-color: #faebb4">Worst: O(n<sup>2</sup></p>
                                <p class="average" style="background-color: #fee446">Average: O(n<sup>2</sup> / 2<sup>p</sup>)</p>
                                <p class="best" style="background-color: #fdc02f">Best: O(n log(n))</p>
                            </div>
                            <div class="explanation">
                                <p align=left style="background-color: #fef8b8">The basic idea is to eliminate turtles, or small values near the end of the list, since in a bubble sort these slow the sorting down tremendously. Rabbits, large values around the beginning of the list, do not pose a problem in bubble sort.
                                
                                In bubble sort, when any two elements are compared, they always have a gap (distance from each other) of 1. The basic idea of comb sort is that the gap can be much more than 1. The inner loop of bubble sort, which does the actual swap, is modified such that gap between swapped elements goes down (for each iteration of outer loop) in steps of a "shrink factor" k: [ n/k, n/k2, n/k3, ..., 1 ].</p>
                            </div>
                        </div>
                    </li>
                    <li>
                        <div class="collapsible-header" style="background-color: #d4c100">Insertion Sort</div>
                        <div class="collapsible-body">
                            <div class="complexity">
                                <p class="worst" style="background-color: #faebb4">Worst: O(n)</p>
                                <p class="average" style="background-color: #fee446">Average: O(n<sup>2</sup>)</p>
                                <p class="best" style="background-color: #fdc02f">Best: O(n<sup>2</sup>)</p>
                            </div>
                            <div class="explanation">
                                <p align=left style="background-color: #fef8b8">Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list. Each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there. It repeats until no input elements remain.</p>
                            </div>
                        </div>
                    </li>
                    <li>
                        <div class="collapsible-header" style="background-color: #cab800">Quicksort</div>
                        <div class="collapsible-body">
                            <div class="complexity">
                                <p class="worst" style="background-color: #faebb4">Worst: O(n log(n))</p>
                                <p class="average" style="background-color: #fee446">Average: O(n<sup>2</sup>)</p>
                                <p class="best" style="background-color: #fdc02f">Best: O(n log(n))</p>
                            </div>
                            <div class="explanation">
                                <p align=left style="background-color: #fef8b8">Quicksort is a divide and conquer algorithm. Quicksort first divides a large array into two smaller sub-arrays: the low elements and the high elements. Quicksort can then recursively sort the sub-arrays.

                                    <br></br>The steps are:<br></br>

                                    <b>1.</b> Pick an element, called a pivot, from the array.<br></br>
                                    
                                    <b>2.</b> Partitioning: reorder the array so that all elements with values less than the pivot come before the pivot, while all elements with values greater than the pivot come after it (equal values can go either way). After this partitioning, the pivot is in its final position. This is called the partition operation.<br></br>
                                    
                                    <b>3.</b> Recursively apply the above steps to the sub-array of elements with smaller values and separately to the sub-array of elements with greater values.<br></br>
                                    
                                The base case of the recursion is arrays of size zero or one, which never need to be sorted.

                                The pivot selection and partitioning steps can be done in several different ways; the choice of specific implementation schemes greatly affects the algorithm's performance.</p>
                            </div>
                        </div>
                    </li>
                    <li>
                        <div class="collapsible-header" style="background-color: #beae00">Radix Sort</div>
                        <div class="collapsible-body">
                            <div class="complexity">
                                <p class="worst" style="background-color: #faebb4">Worst: O(nk)</p>
                                <p class="average" style="background-color: #fee446">Average: O(nk)</p>
                                <p class="best" style="background-color: #fdc02f">Best: O(nk)</p>
                            </div>
                            <div class="explanation">
                                <p align=left style="background-color: #fef8b8">In computer science, radix sort is a non-comparative integer sorting algorithm that sorts data with integer keys by grouping keys by the individual digits which share the same significant position and value. A positional notation is required, but because integers can represent strings of characters (e.g., names or dates) and specially formatted floating point numbers, radix sort is not limited to integers.</p>
                            </div>
                        </div>
                    </li>
                    <li>
                        <div class="collapsible-header" style="background-color: #b2a200">Heap Sort</div>
                        <div class="collapsible-body">
                            <div class="complexity">
                                <p class="worst" style="background-color: #faebb4">Worst: O(n log(n))</p>
                                <p class="average" style="background-color: #fee446">Average: O(n log(n))</p>
                                <p class="best" style="background-color: #fdc02f">Best: O(n log(n))</p>
                            </div>
                            <div class="explanation">
                                <p align=left style="background-color: #fef8b8">The heapsort algorithm involves preparing the list by first turning it into a max heap. The algorithm then repeatedly swaps the first value of the list with the last value, decreasing the range of values considered in the heap operation by one, and sifting the new first value into its position in the heap. This repeats until the range of considered values is one value in length.<br></br>

                                The steps are:<br></br>

                                <b>1.</b> Call the buildMaxHeap() function on the list. Also referred to as heapify(), this builds a heap from a list in O(n) operations.<br></br>
                                <b>2.</b> Swap the first element of the list with the final element. Decrease the considered range of the list by one.<br></br>
                                <b>3.</b> Call the siftDown() function on the list to sift the new first element to its appropriate index in the heap.<br></br>
                                <b>4.</b> Go to step (2) unless the considered range of the list is one element.<br></br>
                                
                                The buildMaxHeap() operation is run once, and is O(n) in performance. The siftDown() function is O(log(n)), and is called n times. Therefore, the performance of this algorithm is O(n + n * log(n)) which evaluates to O(n log n).</p>
                            </div>
                        </div>
                    </li>
                    <li>
                        <div class="collapsible-header" style="background-color: #a49500">Merge Sort</div>
                        <div class="collapsible-body">
                            <div class="complexity">
                                <p class="worst" style="background-color: #faebb4">Worst: O(n log(n))</p>
                                <p class="average" style="background-color: #fee446">Average: O(n log(n))</p>
                                <p class="best" style="background-color: #fdc02f">Best: O(n log(n))</p>
                            </div>
                            <div class="explanation">
                                <p align=left style="background-color: #fef8b8">
                                    Conceptually, a merge sort works as follows:<br></br>

                                    <b>1. </b>Divide the unsorted list into n sublists, each containing 1 element (a list of 1 element is considered sorted).<br></br>
                                    <b>2. </b>Repeatedly merge sublists to produce new sorted sublists until there is only 1 sublist remaining. This will be the sorted list.</p>
                            </div>
                        </div>
                    </li>
                </ul>
            </div>
        </div>
    </main>
    <footer>

    </footer>
    <!-- Compiled and minified JavaScript -->
    <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/0.97.8/js/materialize.min.js"></script>
    <script src="two.min.js"></script>
    <script src="sorting.js"></script>
    <script src="state.js"></script>

    <script>
        var LEN = 25;
        // Retrieve the animation speed integer.
        var delay = $("#delay").val();

        function randArray(length) {
            //grab the arr
            for (var arr = [], i = 0; i < length; ++i) arr[i] = i + 1;

            // http://stackoverflow.com/questions/962802#962890
            var tmp, current, top = arr.length;
            if (top)
                while (--top) {
                    current = Math.floor(Math.random() * (top + 1));
                    tmp = arr[current];
                    arr[current] = arr[top];
                    arr[top] = tmp;
                }
            return arr;
        }


        var arr = randArray(LEN);
        var rects = [];
        var baseState = new State(arr, {});
        var states = [];
        states.push(baseState);
        var currentState = 0;
        var prevState = 0;
        var two, xdef, maxWidth, paddef, barWidth, primary;

        $(document).ready(function() {
            $('.collapsible').collapsible();
            $("#bubble").trigger("click");
            init();
            draw(baseState);
        });

        $(window).resize(function() {
            init();
            draw(states[currentState]);
        });

        $("#currentState").change(function() {
            stop();
            prevState = currentState;
            currentState = $(this).val();
            draw(states[currentState]);
        });

        $("#delay").change(function() {
            stop();
            delay = $(this).val();
        });

        $("#numElements").change(function() {
            stop();
            LEN = $(this).val();
            $("#reset").trigger("click");
            init();
            draw(states[currentState]);
        });

        function init() {
            $("#displayArea").empty();
            $('script[src="two.min.js"]').remove();
            $('<script>').attr('src', 'two.min.js').appendTo('head');
            //initialize two.js
            xdef = 0;
            height = 500;
            maxWidth = window.innerWidth; //definitely look into moving into a setup() function that gets called when the window resizes
            paddef = 1;
            barWidth = ((maxWidth - (paddef * LEN)) / LEN)
            primary = "#ffffff";
            var elem = document.getElementById("displayArea");
            var params = {
                width: maxWidth,
                height: height
            };
            two = new Two(params).appendTo(elem);
        }

        var debstring = "";


        function arrayDiff(a, b) {
            var diffs = [];
            for (var i = 0; i < a.length; i++) {
                if (a[i] != b[i]) {
                    diffs.push(i);
                }
            }
            return diffs;
        };

        function update(state) {
            var diffs = arrayDiff(state.data, states[prevState].data);
            var colorDiffs = arrayDiff(state.colors, states[prevState].colors);
            var max = Math.max(...state.data);
            for (var i = 0; i < diffs.length; i++) {
                var rect = rects[diffs[i]];
                var id = rect.id;
                htmlID = "#" + id
                $(htmlID).remove();
                two.remove(rect);
                var x = xdef + (barWidth * diffs[i]) + (paddef * diffs[i]) + (1 / 2 * barWidth);
                var barHeight = (state.data[diffs[i]] / max) * height;
                rect = two.makeRectangle(x, (height / 2) + (height / 2 - barHeight / 2) + 1, barWidth, barHeight);
                rect.id = id;
                rect.fill = primary;
                rect.noStroke();
            }
            for (var i = 0; i < colorDiffs.length; i++) {
                var rect = rects[colorDiffs[i]];
                if (state.colors[colorDiffs[i]]) {
                    rect.fill = state.colors[colorDiffs[i]];
                } else {
                    rect.fill = primary;
                }
                rect.noStroke();
                //$("#two_" + colorDiffs[i]).prop("fill", state.colors[colorDiffs[i]]);
            }
            two.update();
        }
        //Draws the state passed as a parameter
        function draw(state) {
            two.clear();
            rects = [];
            //iterate through and draw it
            var max = Math.max(...state.data);
            var debug = document.getElementById("debug");
            for (index in state.data) {
                var x = xdef + (barWidth * index) + (paddef * index) + (1 / 2 * barWidth);
                //percent of the maxmimum value, scaled to total height of graph
                var barHeight = (state.data[index] / max) * height;
                var rect = two.makeRectangle(x, (height / 2) + (height / 2 - barHeight / 2) + 1, barWidth, barHeight);
                rects.push(rect);
                //If the color is null, make it default color. Else draw given color for index.
                if (state.colors[index]) {
                    rect.fill = state.colors[index];
                } else {
                    rect.fill = primary;
                }
                rect.noStroke();
            }
            two.update();
        }
        var runner = null;

        function playBack() {
            runner = setInterval(function() {
                stepBack();
            }, delay);
        }

        function start() {
            runner = setInterval(function() {
                stepNext();
            }, delay);
        }

        function stop() {
            clearInterval(runner);
            $("#start").removeClass("disabled");
        }

        //Step to next State

        function stepNext() {
            if (currentState != states.length - 1) {
                prevState = currentState;
                currentState++;
            }
            update(states[currentState]);
            $("#currentState").val(currentState);
            if (currentState == states.length - 1) {
                stop();
            }
        }

        //Go to previous State
        function stepBack() {
            if (currentState != 0) {
                prevState = currentState;
                currentState--;
            }
            update(states[currentState]);
            $("#currentState").val(currentState);
            if (currentState == 0) {
                stop();
            }
        }

        function enableAllButtons() {
            $(".alg").each(function() {
                $(this).removeClass("disabled");
            });
        }
        //*****************************************
        //  Button click handlers
        //  We have the delay values re-assigned
        //  inbetween function calls because we want
        //  to have the most recent updated user
        //  animation speed input.
        //*****************************************
        var obj = document.getElementById("bubble");
        obj.addEventListener("click", function() {
            $("#reset").trigger("click");
            enableAllButtons();
            $("#bubble").addClass("disabled");
            states = bubbleSort(states[currentState].data);
            $("#currentState").prop('max', states.length - 1);
        });

        //set state array to the value returned by selection sort
        obj = document.getElementById("selection");
        obj.addEventListener("click", function() {
            $("#reset").trigger("click");
            enableAllButtons();
            $("#selection").addClass("disabled");
            states = selectionSort(states[currentState].data);
            $("#currentState").prop('max', states.length - 1);
        });

        obj = document.getElementById("cocktail");
        obj.addEventListener("click", function() {
            $("#reset").trigger("click");
            enableAllButtons();
            $("#cocktail").addClass("disabled");
            states = cocktailShakerSort(states[currentState].data);
            $("#currentState").prop('max', states.length - 1);
        });

        obj = document.getElementById("comb");
        obj.addEventListener("click", function() {
            $("#reset").trigger("click");
            enableAllButtons();
            $("#comb").addClass("disabled");
            states = combSort(states[currentState].data);
            $("#currentState").prop('max', states.length - 1);
        });

        obj = document.getElementById("insertion");
        obj.addEventListener("click", function() {
            $("#reset").trigger("click");
            enableAllButtons();
            $("#insertion").addClass("disabled");
            states = insertionSort(states[currentState].data);
            $("#currentState").prop('max', states.length - 1);
        });

        obj = document.getElementById("quick");
        obj.addEventListener("click", function() {
            $("#reset").trigger("click");
            enableAllButtons();
            $("#quick").addClass("disabled");
            states = startQuickSort(states[currentState].data, 0, states[currentState].data.length - 1);
            $("#currentState").prop('max', states.length - 1);
        });

        obj = document.getElementById("radixLSD");
        obj.addEventListener("click", function() {
            $("#reset").trigger("click");
            enableAllButtons();
            $("#radixLSD").addClass("disabled");
            states = radixSortLSD(states[currentState].data);
            $("#currentState").prop('max', states.length - 1);
        });

        obj = document.getElementById("radixMSD");
        obj.addEventListener("click", function() {
            $("#reset").trigger("click");
            enableAllButtons();
            $("#radixMSD").addClass("disabled");
            states = startRadixSortMSD(states[currentState].data);
            $("#currentState").prop('max', states.length - 1);
        });

        obj = document.getElementById("heap");
        obj.addEventListener("click", function() {
            $("#reset").trigger("click");
            enableAllButtons();
            $("#heap").addClass("disabled");
            states = heapSort(states[currentState].data);
            $("#currentState").prop('max', states.length - 1);
        });

        obj = document.getElementById("merge");
        obj.addEventListener("click", function() {
            $("#reset").trigger("click");
            enableAllButtons();
            $("#merge").addClass("disabled");
            states = startMergeSort(states[currentState].data);
            $("#currentState").prop('max', states.length - 1);
        });

        //reset state array. push new rand array.
        //Draw new base array. Set currentState
        obj = document.getElementById("reset");
        obj.addEventListener("click", function() {
            stop();
            states = [];
            init();
            states.push(new State(randArray(LEN), {}));
            draw(states[0]);
            prevState = currentState;
            currentState = 0;
            $("#currentState").val(0);
            $(".disabled").first().trigger("click");
        });

        obj = document.getElementById("stepNext");
        obj.addEventListener("click", function() {
            stop();
            stepNext();
        });

        obj = document.getElementById("stepBack");
        obj.addEventListener("click", function() {
            stop();
            stepBack();
        });

        obj = document.getElementById("start");
        obj.addEventListener("click", function() {
            stop();
            $("#start").addClass("disabled");
            start();
        });

        obj = document.getElementById("stop");
        obj.addEventListener("click", function() {
            stop();
        });

        obj = document.getElementById("playBack");
        obj.addEventListener("click", function() {
            stop();
            playBack();
        });
    </script>
</body>

</html>
